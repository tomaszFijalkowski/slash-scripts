// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Characters/BaseCharacter.h"
#include "Characters/CharacterTypes.h"
#include "Navigation/PathFollowingComponent.h"
#include "Enemy.generated.h"

class AEnemySpawnPoint;
class USphereComponent;
class ACharacterTargetPoint;
class ATargetPoint;
class ASlashCharacter;
class ASoul;
class AAIController;
class UPawnSensingComponent;
class UHealthBarComponent;

UCLASS()
class SLASH_API AEnemy : public ABaseCharacter
{
	GENERATED_BODY()

public:
	AEnemy();

	// <AActor>
	virtual void Tick(float DeltaTime) override;
	virtual float TakeDamage(float DamageAmount, const FDamageEvent& DamageEvent,
	                         AController* EventInstigator, AActor* DamageCauser) override;
	virtual void Destroyed() override;
	// </AActor>

	// <IHitInterface>
	// GetHit_Implementation is generated by UFUNCTION(BlueprintNativeEvent)
	virtual void GetHit_Implementation(const FVector& ImpactPoint, ABaseCharacter* Hitter) override;
	// </IHitInterface>

	void Alert(APawn* SeenPawn);
	void StartPatrolling();

	void Activate();
	void Deactivate();

	float GetCurrentHealth();
	void SetCurrentHealth(const float Health);

protected:
	// <AActor>
	virtual void BeginPlay() override;
	// </AActor>

	// <ABaseCharacter>
	virtual void Die_Implementation() override;
	virtual void AttackEnd() override;
	virtual void HitReactEnd() override;
	virtual void HandleDamage(const float DamageAmount) override;
	virtual void HandlePoisonDamageOverTime(const float DeltaTime) override;
	// </ABaseCharacter>

	UFUNCTION()
	virtual void OnSphereBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
	                                  UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep,
	                                  const FHitResult& SweepResult);

	UFUNCTION()
	virtual void OnSphereEndOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
	                                UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

	UFUNCTION(BlueprintCallable)
	void SelectWarpTargetEnd();

	UFUNCTION(BlueprintCallable)
	FVector GetTranslationWarpTarget();

	UFUNCTION(BlueprintCallable)
	FVector GetRotationWarpTarget();

	UPROPERTY(BlueprintReadOnly)
	EEnemyState EnemyState = EEnemyState::EES_Patrolling;

	UPROPERTY(BlueprintReadOnly)
	TObjectPtr<ASlashCharacter> CombatTarget;

	// How offset should the warp target location be.
	// Negative value means closer to the player, positive value means further away
	UPROPERTY(EditAnywhere, Category = "Combat")
	double WarpTargetOffset = -37.5f;

	// How far away from itself can enemy warp
	UPROPERTY(EditAnywhere, Category = "Combat")
	double MaxWarpDistance = 100.f;

	UPROPERTY(VisibleAnywhere, BlueprintReadWrite)
	TObjectPtr<USphereComponent> Sphere;

private:
	void HideHealthBar();
	void ShowHealthBar();

	// AI Behavior
	void CheckPatrolTarget();
	void CheckCombatTarget();

	bool IsDead();
	bool IsPatrolling();
	bool IsChasing();
	bool IsAttacking();
	bool IsEngaged();

	bool IsInPatrolAcceptanceRadius();
	bool IsOutsideCombatRadius();
	bool IsOutsideAttackRadius();
	bool IsInsideAttackRadius();

	bool ShouldRespondToAlert(const APawn* SeenPawn);

	void LoseInterest();
	void ChaseTarget();

	void PatrolTimerFinished();
	void ClearPatrolTimer();

	void SetCombatTarget(APawn* Pawn);
	void ClearCombatTarget();

	void StartClosestTargetPointUpdateTimer();

	bool CanUpdateClosestTargetPoint();
	void SetClosestTargetPointToOccupy();
	void UpdateClosestTargetPointToOccupy();
	ACharacterTargetPoint* FindClosestTargetPointToOccupy();

	bool CanAttack();
	void Attack();

	void StartAttackTimer();
	void ClearAttackTimer();

	ATargetPoint* ChoosePatrolTarget();

	void SpawnDefaultWeapon();

	bool InTargetRange(const AActor* Target, const double Radius, const bool bIgnoreElevation = false);
	void MoveToTarget(const ATargetPoint* Target, float AcceptanceRadius);
	void SpawnSoul();

	void OnMoveCompleted(FAIRequestID RequestID, const FPathFollowingResult& Result);

	UFUNCTION()
	void PawnSeen(APawn* SeenPawn); // Callback for OnPawnSeen in UPawnSensingComponent

	void AlertNearbyAllies();

	UPROPERTY()
	TObjectPtr<AAIController> EnemyController;

	UPROPERTY(VisibleAnywhere)
	TObjectPtr<UHealthBarComponent> HealthBarComponent;

	UPROPERTY(VisibleAnywhere)
	TObjectPtr<UPawnSensingComponent> PawnSensing;

	UPROPERTY(EditAnywhere, Category = "Combat")
	TSubclassOf<AWeapon> WeaponClass;

	UPROPERTY()
	FAIMoveRequest MoveRequest;

	UPROPERTY()
	FTimerHandle ClosestTargetPointUpdateTimer;

	UPROPERTY(EditAnywhere, Category = "AI Navigation")
	float ClosestTargetPointUpdateTimerFrequency = 0.2f;

	UPROPERTY(EditAnywhere, Category = "AI Navigation")
	bool ShouldOccupyInnerTargetPoint = false;

	UPROPERTY(VisibleAnywhere, Category = "AI Navigation")
	TObjectPtr<ACharacterTargetPoint> OccupiedTargetPoint;

	UPROPERTY(EditInstanceOnly, Category = "AI Navigation")
	TObjectPtr<ATargetPoint> CurrentPatrolTarget;

	UPROPERTY(EditInstanceOnly, Category = "AI Navigation")
	TArray<TObjectPtr<ATargetPoint>> PatrolTargets;

	UPROPERTY(EditAnywhere, Category = "AI Navigation")
	double PatrolAcceptanceRadius = 75.f;

	UPROPERTY(EditAnywhere, Category = "AI Navigation")
	double PatrolAcceptanceRadiusMargin = 50.f;

	UPROPERTY(EditAnywhere, Category = "AI Navigation")
	float PatrolWaitTimeMin = 2.f;

	UPROPERTY(EditAnywhere, Category = "AI Navigation")
	float PatrolWaitTimeMax = 4.f;

	UPROPERTY()
	FTimerHandle PatrolTimer;

	UPROPERTY(EditInstanceOnly, Category = "Combat")
	TArray<TObjectPtr<AEnemy>> AlliedEnemies;

	UPROPERTY(EditAnywhere, Category = "Combat")
	double AlertRadius = 600.f;

	UPROPERTY(EditAnywhere, Category = "Combat")
	double AlertDelay = 0.35f;

	UPROPERTY()
	FTimerHandle AlertTimer;

	// Needs to be bigger than SightRadius or enemy will lose interest as soon as he sees you
	UPROPERTY(EditAnywhere, Category = "Combat")
	double CombatRadius = 1600.f;

	UPROPERTY(EditAnywhere, Category = "Combat")
	double AttackRadius = 250.f;

	UPROPERTY(EditAnywhere, Category = "Combat")
	double ChaseAcceptanceRadius = 5.f;

	UPROPERTY(EditAnywhere, Category = "Combat")
	float PatrolSpeed = 125.f;

	UPROPERTY(EditAnywhere, Category = "Combat")
	float ChaseSpeed = 325.f;

	UPROPERTY(EditAnywhere, Category = "Combat")
	float AttackMin = 0.2f;

	UPROPERTY(EditAnywhere, Category = "Combat")
	float AttackMax = 0.4f;

	UPROPERTY()
	FTimerHandle AttackTimer;

	UPROPERTY(EditAnywhere, Category = "Combat")
	float DeathLifeSpan = 30.f;

	UPROPERTY()
	bool bShouldSelectWarpTarget;

	UPROPERTY()
	bool bHasExceededWarpDistance;

	UPROPERTY()
	FVector WarpTarget;

	UPROPERTY(EditAnywhere, Category = "Combat")
	TSubclassOf<ASoul> SoulClass;

	UPROPERTY(VisibleInstanceOnly)
	TObjectPtr<AEnemySpawnPoint> SpawnPoint;

public:
	FORCEINLINE void SetSpawnPoint(const TObjectPtr<AEnemySpawnPoint>& Point) { SpawnPoint = Point; }
	FORCEINLINE TObjectPtr<ATargetPoint> GetCurrentPatrolTarget() const { return CurrentPatrolTarget; }
	FORCEINLINE void SetCurrentPatrolTarget(const TObjectPtr<ATargetPoint>& Target) { CurrentPatrolTarget = Target; }
	FORCEINLINE void SetPatrolTargets(const TArray<TObjectPtr<ATargetPoint>>& Targets) { PatrolTargets = Targets; }
	FORCEINLINE void SetAlliedEnemies(const TArray<TObjectPtr<AEnemy>>& Enemies) { AlliedEnemies = Enemies; }
};
